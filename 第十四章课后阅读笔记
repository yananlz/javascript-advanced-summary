除了一些特殊字符，所有的字符都匹配它们自身。
特殊字符：\f:翻页符 、\n换行符、\r回车、\t水平制表符、\v垂直制表符、\0匹配NUL字符(\U0000) 、任何控制字符：\cA~\cZ。
字符分类转义：\d:匹配任意数字，\D匹配任何非数字，\w匹配任意拉丁文字符数字字符和下划线，\W匹配所有\w不匹配的字符，
\s匹配空白字符(空表、制表符、换行符、回车符、翻页符和所有Unicode空格等)，\S匹配所有非空白字符。
[<<charSpecs>>]:至少匹配<charSpecs中的任意一个字符；[^<<charSpecs>>]:匹配不属于charSpecs的任意一个的字符。
源字符与自身匹配。大多数字符是源字符。
(<<pattern>>)：是捕获组。任意匹配pattern的内容都可以通过反向引用访问或作为匹配操作的结果。(?:<<pattern>>)：是非捕获组。pattern仍就匹配输入，但不保存捕获的内容。因此，这种数组没有数字可以引用(例如，通过反向引用)。
\1,\2依次类推称为反向引用；它们指向之前匹配的分组。反斜线后的数字可以是任何大于或等于1的整数，但第一个数字必须不是0。
量词可以跟随在任何原子(包括字符类和分组)后。?：表示从未匹配或只匹配一次。*：表示匹配0次或多次。+:表示匹配一次或多次。{n}：表示完全匹配n次。{n,}:表示匹配n次或多次。{n,m}：表示匹配最少n次，最多匹配m次。
默认情况下，量词是贪婪匹配的，也就是说，它们尽可能多地匹配。可以勉强匹配(尽可能少)，通过后面添加上述任何量词(包括在大括号地范围内)和问号。
*?:是十分实用地模式，它可以匹配一切，直到后面地原子出现。
断言(下面地断言用来检测输入的当前位置)：^:只匹配输入的开始位置，$:只匹配输入结束位置，\b：只匹配单词的边界,[\b]:匹配一个退格，\B：只匹配非单词边界。
(?=<<pattern>>):正向肯定断言，只匹配pattern所匹配的接下来的内容。pattern只是用来向前查找，但会忽略匹配的pattern部分，
(?!<<pattern>>):正向否定断言：只匹配pattern不匹配的接下来的内容。pattern只是用来向前查找，但会忽略匹配的pattern部分。
可以通过字面量表达式或构造函数创建正则表达式，并通过标识配置它如何工作。
正则表达式有两种创建方法：字面量：/xyz/i 加载时编译  构造函数：new RegExp('xyz','i')运行时编译。动态拼装则正则表达式，需要使用构造函数。
标识是正则表达式字面量的后缀和正则表达式构造函数的参数，它修改正则表达式的匹配行为。g:给定的正则表达式可以匹配多次，会影响几种方法，尤其是replace（）,i:试图匹配给定的正则表达式时忽略大小写，
M：在多行模式时，开始操作符^和结束操作符$pi匹配每一行，而不是输入的整个字符串。
正则表达式具有以下实例属性：标识：布尔值，指示设置什么标志。多次匹配数据。
RegExp.prototype.test:是否存在匹配test()方法用来检查正则表达式regex是否匹配字符串str regex.test(str)
String.prototype.search：匹配位置的索引 search()方法查找str匹配regex的位置： str.search(regex);进行查找时，regex的global和lastIndex（没有改变）属性被忽略。
RegExp.prototype.exec:捕获分组 例：var matchData=regex.exec(str)//用在str匹配regex的同时捕获分组。如果没有匹配，matchData为null，否则，matchData为匹配结果，是带有两个附加属性的数组：(1):数组元素(2):属性
(1):数组元素：元素0是完整正则表达式的匹配结果；元素n>1是捕获的分组N(2):input是输入的完整字符串；index是找到匹配处的索引。
String.prototype.match:捕获分组或返回所有匹配的子字符串。String.prototype.replace:查找和替换  例：str.replace(search,replacement)//replace()方法在字符串str中进行查找，匹配search并用replacement替换匹配项。
search:字符串或正则表达式；replacement：字符串或函数。
标识/g的问题：带有/g的正则表达式不能内联 带有/g的正则表达式作为参数，需要多次调用test()和exex()时，把正则表达式作为参数传递给方法时必须要小心。必须设置/g标识，为了安全起见，设置lastIndex为0。共享带有/g的正则表达式。。。
缺少断言(^ $)的正则表达式可以在任意位置匹配。空的正则表达式可以匹配一切，var never=/.^/;never.test('abc') //false  never.test('')//false
正则表达式中圆括号的作用：把独立的项组合成子表达式；在完整的模式中定义子表达式；允许在同一正则表达式的后部引用前面的子表达式。
正则表达式对子表达式进行分组：以'(?:)'和')'分组。任意正则表达式都可以作为锚点条件。
正则表达式修饰符：i：执行不区分大小写的匹配；g：执行一个全局匹配，简言之，即找到所有的匹配，而不是在找到第一个后就停止；m:多行匹配模式，^匹配一行的开头和字符串的开头，$匹配行的结束和字符串的结束。
RegExp的属性：source：只读的字符串，包含正则表达式的文本。global:是一个只读的布尔值。lastIndex:它是一个可读/写的整数。如果模式匹配模式带有g修饰符，这个属性存储在整个字符串中有一个检索的开始位置，这个属性会被exec()和test()方法用到。。。
