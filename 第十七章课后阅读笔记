事实上，程序中出现在运行部分和将来运行部分之间的关系就是异步编程的核心。最常见的块单位是函数。
从现在到将来的“等待”，最简单的方法是使用一个通常称为回调函数的函数。
console.*方法族并不是JS正式的一部分，而是由宿主环境添加到JS中的。
所有的宿主环境都有一个共同“点”,即它们都提供了一种机制来处理程序中多个块的执行，且执行每块时调用JS引擎，这种机制被称为事件循环。
换句话说，JS引擎本身并没有时间的概念，只是一个按需执行JS任意代码片段的环境。“事件”调度总是由包含它的环境运行。
并行（是关于能够同时发生的事情）：计算最常见的工具是进程和线程。进程和线程独立运行，并可能同时运行；在不同的处理器，甚至不同的计算机上，但多个线程线程能够共享单个进程的内存。
与之相对的是，事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存。
JS从不跨线程共享数据。在JS的特性中，函数顺序的不确定性就是通常所说的竞态条件。
两个或多个“进程”在同一个程序内并行地交替运行它们地步骤/事件时，如果这些任务彼此不相关，就不一定需要交互。如果进程间没有互相影响的话，不确定性时是完全可以接受的。
任务队列理解：它是挂在事件循环队列的每个tick之后的一个队列。在事件循环的每个tick中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前tick的任务队列末尾添加一个项目（一个任务）。
一个任务可能引起更多任务被添加到同一个队列末尾。所以，理论上说，任务循环可能无限循环，进而导致程序的饿死，无法转移到下一个事件循环tick。从概念上看，这和代码中的无限循环的体验几乎是一样的。
JS引擎在编译期间执行的都是安全的优化，最后可见的结果都是一样的。
并发是指两个或多个事件链随事件发展交替执行，以至于从更高层次来看，就像是同时在运行。
通常需要对这些并发执行的“进程”进行某种形式的交互协调，比如需要确保执行顺序或者需要防止竞态出现。这些“进程”也可以通过把自身分割成更小的块，以便其他“进程”插入进来。
控制反转：自己程序一部分的执行控制交给某个第三方。在自己的代码和第三方工具之间有一份并没有明确表达的契约。
ES6 Promise API使用的是分离回调设计：一个用于成功通知，一个用于出错通知。
“error-first风格”/Node风格回调模式：回调的第一个参数保留用作错误对象，如果成功的话，这个参数就会被清空/置假。
Node风格缺点：并没有真正解决主要的信任问题；冗长和模式化、可复用性不高。
回调函数是JS异步的基本单元。但是随着JS越来越热，对于异步编程领域的发展，回调已经不够用了。
回调表大异步流程的方式是非线性的、非顺序的。
回调会受到控制反转的影响，因为回调暗中把控制权交给第三方来调用自己代码中的continuation。这种控制转移导致了一系列信任问题。
事件目标是发生的事件或与之相关的对象。当讲事件时，我们必须同时指明类型和目标。事件处理程序或事件监听程序是处理或响应事件的函数。
事件对象是与特定事件相关且包含有关事件详细信息的对象。事件对象作为参数传递给事件处理程序函数。事件传播是浏览器决定哪个对象触发其事件处理程序的过程。
focus和blur事件不会冒泡。
windows事件：是指事件的发生与浏览器窗口本身而非窗口中显示的任何特定文档内容相关。但是，这些事件中有一些会和文档内容上发生的事件同名。
unload事件处理程序可以保存用户的状态，但它不能用于取消用户转向其他地方。beforeunload事件能提供用户是否确定离开当前页面的机会。如果返回字符串，那么在新页面加载之前，
字符串会出现在展示给用户确认的对话框上，这样用户将有机会取消其跳转而留在当前页上。
键盘快捷键对于操作系统和浏览器本身有特殊意义，它们通常被操作系统或浏览器“吃掉”并对JS事件处理程序不可见。无论任何文档元素获取键盘焦点都会触发键盘事件，并且它们会冒泡到Document和Windows对象。
3级DOM事件规范标准化了不冒泡的focusin和focusout事件来取代冒泡的focus和blur事件，标准化了mouseenter和mouseleave事件来取代不冒泡的mouseover和mouseout事件。
H5定义了表单验证机制，包括验证失败时在表单元素上会触发invalid事件。
Safari产生的手势事件用于两个手指的缩放和旋转手势。当手势开始生成gesturetart事件，而手势结束时产生gestureend事件。在这两个事件之间是跟踪手势过程的gesturechange事件队列。
这些事件传递的事件对象有数字属性scale和rotation。scale属性是两个手指之间当前距离和初始距离的比值。‘捏紧’手势的scale值小于1.0，而‘撑开’手势的scale值大于1.0。
rotation属性是指从事件开始手指旋转的角度，它以度为单位，正值表示按照顺时针方向旋转。手势事件是高级事件，用于通知已经翻译的手势。触摸事件并不直接报告触摸的目标。
触摸事件传递的事件对象有一个changedTouches属性，该属性是一个类数组对象，其每个元素都描述触摸的位置。
注册事件处理程序两种基本方式：1>给事件目标对象或文档元素设置属性2>将事件处理程序传递给对象或元素的一种方法。
addEventListener()：可以为事件目标注册事件处理程序。接收三个参数：第一个是要注册处理程序的事件类型，这个事件类型是字符串，不包括用于设置事件处理程序属性的前缀“on”。
第二个参数是指定类型的事件发生时应该调用的函数。最后一个参数是布尔值：通常传入false，若传入true，那么函数将注册为捕获事件处理程序，并在事件不同的调度阶段调用。
一旦注册了事件处理程序，浏览器就会在指定对象上发生指定类型事件时会自动调用它。
在事件处理程序内，this关键字指的是事件目标。
事件处理程序从词法上讲也是作用域，它们在其定义时的作用域而非调用时的作用域中执行，并且它们能存取那个作用域中的任何一个本地变量。
浏览器按照如下规则调用所有的事件处理程序：通过设置对象属性或HTML属性注册的处理程序一直优先调用；使用addEventListener()注册的处理程序按照它们的注册顺序调用，使用attachEvent()注册的处理程序可能按照任何顺序调用，所以代码不应该依赖于调用顺序。
可以通过调用事件对象的preventDefault()方法取消事件的默认操作。
在支持addEventListener()的浏览器中，可以调用事件对象的一个stopPropagation()方法以阻止事件的继续传播。
调用stopPropagation()之后任何其他对象上的事件处理程序将不会被调用。
