《JavaScript权威指南》第17章1/2/3节
事实上，程序中出现在运行部分和将来运行部分之间的关系就是异步编程的核心。最常见的块单位是函数。
从现在到将来的“等待”，最简单的方法是使用一个通常称为回调函数的函数。
console.*方法族并不是JS正式的一部分，而是由宿主环境添加到JS中的。
所有的宿主环境都有一个共同“点”,即它们都提供了一种机制来处理程序中多个块的执行，且执行每块时调用JS引擎，这种机制被称为事件循环。
换句话说，JS引擎本身并没有时间的概念，只是一个按需执行JS任意代码片段的环境。“事件”调度总是由包含它的环境运行。
并行（是关于能够同时发生的事情）：计算最常见的工具是进程和线程。进程和线程独立运行，并可能同时运行；在不同的处理器，甚至不同的计算机上，但多个线程线程能够共享单个进程的内存。
与之相对的是，事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存。
JS从不跨线程共享数据。在JS的特性中，函数顺序的不确定性就是通常所说的竞态条件。
两个或多个“进程”在同一个程序内并行地交替运行它们地步骤/事件时，如果这些任务彼此不相关，就不一定需要交互。如果进程间没有互相影响的话，不确定性时是完全可以接受的。
任务队列理解：它是挂在事件循环队列的每个tick之后的一个队列。在事件循环的每个tick中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前tick的任务队列末尾添加一个项目（一个任务）。
一个任务可能引起更多任务被添加到同一个队列末尾。所以，理论上说，任务循环可能无限循环，进而导致程序的饿死，无法转移到下一个事件循环tick。从概念上看，这和代码中的无限循环的体验几乎是一样的。
JS引擎在编译期间执行的都是安全的优化，最后可见的结果都是一样的。
并发是指两个或多个事件链随事件发展交替执行，以至于从更高层次来看，就像是同时在运行。
通常需要对这些并发执行的“进程”进行某种形式的交互协调，比如需要确保执行顺序或者需要防止竞态出现。这些“进程”也可以通过把自身分割成更小的块，以便其他“进程”插入进来。
控制反转：自己程序一部分的执行控制交给某个第三方。在自己的代码和第三方工具之间有一份并没有明确表达的契约。
ES6 Promise API使用的是分离回调设计：一个用于成功通知，一个用于出错通知。
“error-first风格”/Node风格回调模式：回调的第一个参数保留用作错误对象，如果成功的话，这个参数就会被清空/置假。
Node风格缺点：并没有真正解决主要的信任问题；冗长和模式化、可复用性不高。
回调函数是JS异步的基本单元。但是随着JS越来越热，对于异步编程领域的发展，回调已经不够用了。
回调表大异步流程的方式是非线性的、非顺序的。
回调会受到控制反转的影响，因为回调暗中把控制权交给第三方来调用自己代码中的continuation。这种控制转移导致了一系列信任问题。
事件目标是发生的事件或与之相关的对象。当讲事件时，我们必须同时指明类型和目标。事件处理程序或事件监听程序是处理或响应事件的函数。
事件对象是与特定事件相关且包含有关事件详细信息的对象。事件对象作为参数传递给事件处理程序函数。事件传播是浏览器决定哪个对象触发其事件处理程序的过程。
