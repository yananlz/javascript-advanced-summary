以表达式定义的函数，函数的名称是可选的。
一个函数定义表达式包含名称，函数的局部作用域将会包含一个绑定到函数对象的名称。
嵌套函数变量作用域规则：可以访问嵌套它们（或多重嵌套）的函数的参数和变量。
调用JS函数的4种方法：作为函数、作为方法、作为构造函数、通过它们的call()和apply()方法间接调用。
1.作为普通函数调用：1>函数返回值：如果该函数返回是因为解释器到达结尾，返回值是undefined。return后面有语句，返回语句值，return后面没有语句，返回undefined；ECS3非严格模式ECM5，函数调用，调用上下文为全局对象。严格模式下，调用上下文是undefined。
以函数形式调用的函数通常不使用this关键字。
2.作为方法调用：调用上下文为对象，函数体可以通过使用关键字this引用该对象。
方法链：当方法的返回值是一个对象，这个对象还可以再调用它的方法。这种方法调用序列中的每次调用结果都是另外一个表达式的组成部分。有一些函数用作内部函数或私有函数，这种函数通常以一条下划线为前缀。
以表达式定义个函数在定义之前无法调用。
return语句会导致函数停止执行，并返回它的表达式的值给调用者。如果return语句没有一个与之相关的表达式，则它返回undefined值。
如果一个函数不包含return语句，那它只执行函数体中的每条语句，并返回undefined值给调用者。
以语句声明形式定义个函数不能出现在循环、条件判断或try/cache/finally/with语句中。
调用函数的4种方式：作为函数、作为方法、作为构造函数、通过call()、apply()方法间接调用。
对于普通的函数调用，函数的返回值成为调用表达式的值。
当方法的返回值是一个对象，这个对象还可以再调用它的方法。这种方法调用序列中，每次的调用结果都是另外一个表达式的组成部分。
错误观点：调用嵌套函数时this会指向外层函数的上下文。
构造函数没有形参，JS构造函数调用的语法是允许省略实参列表和圆括号的。
JS中函数是对象。
arguments指向实参对象的引用，实参对象是一个类数组对象，实质是Object类型。arguments包含一个length属性
“不定实参函数”：可以接收人一个数的实参，不定实参函数实参个数不能为0。
实参对象具有：callee、caller属性。在严格模式下，对这两个属性的读写操作会产生一个类型错误。
在非严格模式下，callee属性指代当前正在执行的函数。
caller是非标准的，指代调用当前正在执行的函数的函数，大多数浏览器实现了这个属性。通过caller属性可以访问调用栈。
callee属性在匿名函数中来递归调用自身。例：var factorial=function(x){ if(x<=1) return 1;return x*arguments.callee(x-1);}
在JS中是无法声明只在一个代码块内可见的变量的，基于这个原因，我们常简单地定义一个函数用作临时地命名空间，在这个命名空间内定义地变量不会污染到全局命名空间。
变量作用域是在函数定义时决定的。函数对象可以通过作用域链相互关联起来，函数体内部地变量可以保存在函数作用域内，这种特性称为“闭包”。
关联到闭包地作用域链都是‘活动的’。
函数嵌套不会将作用域内的私有成员复制一份，也不会对所绑定地变量生成静态快照。
函数的length属性是只读属性，代表函数参数的数量，这里的参数指的是‘形参’。
prototype是属性指向原型对象的引用。当将函数用作构造函数时，新创建的对象会从原型对象上继承属性。
call()和apply（）方法的第一个实参是要调用函数的母对象，它是调用上下文，在函数体内可以通过this来获得对它的引用。
对于call()来说，第一个调用上下文实参之后的所有实参要传入待调用函数的值。例：f.call(p,1,2):以对象p的方法的形式调用函数f()，并传入两个实参。
apply()所有实参都放在一个数组中：f.apply(p,{1,2});
bind()：主要作用是将函数绑定至某个对象。bind()除第一个实参之外，传入bind()的实参会绑定至this。
bind()返回一个函数对象，这个函数对象的length属性是绑定函数的形参个数减去绑定实参的个数（length的值不能小于0）。
Function()构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体。它可以包含任意的JS语句，每两条语句之间用分号分隔。
Function（）构造函数允许JS在运行时动态地创建并编译函数。Function（）所创建地函数并不使用词法作用域。函数体代码地编译总是会在顶层函数执行。
高阶函数：操作函数地函数，可以接收一个或多个函数作为参数，并返回一个新函数。
阶乘函数可以将上次的计算结果缓存起来。在函数式编程当中，这种缓存技巧叫做‘记忆’。
函数声明完全可以提升，变量声明则是部分提升（赋值不可以提升）。
具名参数通过名称来做变量地映射。在函数定义中名称会与形参做关联，在函数调用中，名称与实参作官联。
只要参数地名称正确，则不需要关心参数名地顺序。
JS原本不支持具名参数。我们可以通过对象字面量来命名参数，并将对象作为一个实参来传入函数。
程序：静态性（词法性）（描述性的词法就像是静态声明，涉及到了程序的词法（单词、源码））、动态性（表示一个程序在运行期所表现出来的特性）
变量的作用域：变量可以在何处被访问到。词法作用域：JS中的变量都有词法作用域，一个程序的静态结构决定了变量的作用域（这个作用域并不会被函数从哪里调用等影响）。
嵌套作用域：如果在一个变量的直接作用域中嵌套有多个作用域，那么这个变量在所有的这些作用域中可以访问到。
覆盖：如果在一个作用域中声明了一个与外层作用域同名的变量，那么在这个内部作用域以及其内部的所有作用域中将访问不到外面的变量。
而内部的变量的变化并不影响外部的变量，当离开内部作用域，外部变量又可以被访问了。
JS的变量是函数级作用域：只有函数可以产生新的作用域。
函数声明可以被整体提前，变量只能声明提前，赋值不可以。
IIFE:立即执行、必须是一个表达式、最后有分号。
可以使用前缀运算符来强制执行一个表达式，例：！function(){}();void运算符也可以。好处：分号可以省略。
可以使用参数的方式在IIFE的内部定义变量：var x=23; (function(twice){console.log(twice);}(x*2));
IIFE的使用场景：避免全局变量、隐藏全局作用域的变量、创建新的环境、避免共享、保持全局的数据对于构造器的数据相对独立、将全局数据附加到单例对象上、将全局数据附加到方法中。
全局作用域两大缺点：程序不健壮、重用性低；变量名字冲突。
模块系统解决了全局变量的问题。模块不会通过全局作用域提供接口，并且每一个模块都为它其中的模块全局变量提供了自己的作用域。
全局对象：JS一些不常用的特性可以通过一个对象来为全局的变量创建环境，这个对象就是全局对象。
全局对象可以用来创建、读取或是修改全局变量。全局对象有原型：getAllPropertyNames()函数来罗列全局对象的属性。
浏览器中全局对象是window,文档对象模型（DOM）的一部分。Node.js的全局对象是global,是Node.js的专属变量。
每一个模块都有它自己的作用域，在这个作用域中this指向了这个作用域的对象。因此，this和global在模块中是不同的。
window的使用场景：创建全局变量、内置插件、风格检查器、检查一个全局变量是否存在（不常用）、在全局作用域中创建内容。
环境：提供存储空间的数据结构，将变量名与变量的值做映射。环境被存储在堆中。
变量的两种传递方式：动态维度:调用函数；词法维度：与外部作用域进行关联。
[[Scope]]：JS内部属性、记录函数的作用域。
函数调用时，JS会为这个函数所在的新作用域创建一个环境。这个环境有一个外层域（outer），它通过[[Scope]]创建并指向了外部作用域的环境。
JS中一直存在一个环境链，以当前环境为起点，连接了一层外部环境。
每一个环境链最终会在全局环境（它是所有函数初始化调用的作用域）终结。全局环境的外部环境指向了null。
闭包：函数+函数创建时所创建的作用域。闭包会造成环境共用。



